<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Case: Energy Generation Tracking</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }
        header {
            background: #0078d7;
            color: white;
            padding: 1rem 2rem;
            text-align: center;
        }
        section {
            padding: 2rem;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background: #f4f4f4;
            padding: 1rem;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>Business Case</h1>
        <h2>Energy Generation Tracking</h2>
    </header>
    <section>
        <h3>1. Arrays</h3>
        <p>Description: Arrays are used to store daily energy generation data for different sources, allowing efficient iteration and tracking.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    vector&lt;int&gt; energy = {250, 300, 200, 150};

    cout &lt;&lt; "Daily Energy Generation:\n";
    for (int i = 0; i < energy.size(); ++i) {
        cout &lt;&lt; "Day " &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; energy[i] &lt;&lt; " kWh\n";
    }

    return 0;
}
        </code>
        </pre>

        <h3>2. Stacks</h3>
        <p>Description: Stacks are used to temporarily store energy generation data while processing, especially when reversing or undoing operations is required.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;stack&gt;

using namespace std;

int main() {
    stack&lt;int&gt; energyStack;

    // Push daily energy generation data onto the stack
    energyStack.push(250);
    energyStack.push(300);
    energyStack.push(200);
    energyStack.push(150);

    cout &lt;&lt; "Processing Energy Data (Reversed Order):\n";
    while (!energyStack.empty()) {
        cout &lt;&lt; "Energy: " &lt;&lt; energyStack.top() &lt;&lt; " kWh\n";
        energyStack.pop(); // Remove processed data
    }

    return 0;
}
        </code>
        </pre>

        <h3>3. Queues</h3>
        <p>Description: Queues are used to manage energy distribution tasks in a First-In-First-Out (FIFO) order, ensuring sequential processing.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    queue&lt;string&gt; energyQueue;

    // Adding energy distribution tasks
    energyQueue.push("Distribute to Battery A");
    energyQueue.push("Distribute to Battery B");
    energyQueue.push("Distribute to Grid");

    cout &lt;&lt; "Energy Distribution Queue:\n";
    while (!energyQueue.empty()) {
        cout &lt;&lt; energyQueue.front() &lt;&lt; endl;
        energyQueue.pop(); // Process the task
    }

    return 0;
}
        </code>
        </pre>

        <h3>4. Graphs</h3>
        <p>Description: Graphs represent connections between energy sources (e.g., solar panels, wind turbines) and storage units. Optimizes energy flow using graph traversal techniques.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;

using namespace std;

void bfsEnergyFlow(unordered_map&lt;string, vector&lt;string&gt;&gt; &graph, const string &start) {
    queue&lt;string&gt; q;
    unordered_map&lt;string, bool&gt; visited;

    q.push(start);
    visited[start] = true;

    cout &lt;&lt; "Energy Flow Sequence:\n";
    while (!q.empty()) {
        string node = q.front();
        q.pop();
        cout &lt;&lt; "Source/Storage Unit: " &lt;&lt; node &lt;&lt; endl;

        for (const string &neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    unordered_map&lt;string, vector&lt;string&gt;&gt; graph = {
        {"SolarPanel", {"Battery1", "Battery2"}},
        {"Battery1", {"Grid"}},
        {"Battery2", {"Grid"}},
        {"Grid", {}}
    };

    bfsEnergyFlow(graph, "SolarPanel");

    return 0;
}
        </code>
        </pre>

        <h3>5. Dynamic Programming</h3>
        <p>Description: Dynamic Programming is used to optimize energy usage by determining the maximum energy storage achievable without exceeding storage capacity.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int maxEnergyStorage(vector&lt;int&gt; &energy, int capacity) {
    vector&lt;int&gt; dp(capacity + 1, 0);

    for (int e : energy) {
        for (int j = capacity; j &gt;= e; --j) {
            dp[j] = max(dp[j], dp[j - e] + e);
        }
    }

    return dp[capacity];
}

int main() {
    vector&lt;int&gt; energy = {250, 300, 150, 200}; // Energy in kWh
    int capacity = 500; // Storage capacity in kWh

    int result = maxEnergyStorage(energy, capacity);
    cout &lt;&lt; "Maximum energy storage achievable: " &lt;&lt; result &lt;&lt; " kWh\n";

    return 0;
}
        </code>
        </pre>
    </section>
</body>
</html>



