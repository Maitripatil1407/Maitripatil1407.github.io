<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Cases: Solar Powered Irrigation Scheduling & Energy Generation Tracking</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }
        header {
            background: #0078d7;
            color: white;
            padding: 1rem 2rem;
            text-align: center;
        }
        section {
            padding: 2rem;
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background: #f4f4f4;
            padding: 1rem;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>Business Cases</h1>
        <h2>1. Solar Powered Irrigation Scheduling</h2>
    </header>
    <section>
        <h3>1. Queues</h3>
        <p>Description: Queues are used to schedule irrigation tasks in a First-In-First-Out (FIFO) order. Tasks are added to the queue based on priority and processed one by one.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    queue&lt;string&gt; irrigationQueue;

    // Adding tasks to the irrigation queue
    irrigationQueue.push("Irrigate Field A");
    irrigationQueue.push("Irrigate Field B");
    irrigationQueue.push("Irrigate Field C");

    cout &lt;&lt; "Irrigation Queue Processing:\n";
    while (!irrigationQueue.empty()) {
        cout &lt;&lt; irrigationQueue.front() &lt;&lt; endl; // Process the task at the front
        irrigationQueue.pop();                  // Remove the processed task
    }

    return 0;
}
        </code>
        </pre>

        <h3>2. Dynamic Programming</h3>
        <p>Description: Dynamic Programming optimizes water usage by calculating the minimum water required to meet all crop needs. The goal is to ensure efficient resource allocation.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int minWaterUsage(vector&lt;int&gt; &fields, int totalWater) {
    vector&lt;int&gt; dp(totalWater + 1, INT_MAX);
    dp[0] = 0;

    for (int water : fields) {
        for (int j = totalWater; j &gt;= water; --j) {
            if (dp[j - water] != INT_MAX) {
                dp[j] = min(dp[j], dp[j - water] + 1);
            }
        }
    }

    return dp[totalWater] == INT_MAX ? -1 : dp[totalWater];
}

int main() {
    vector&lt;int&gt; fields = {3, 5, 7}; // Water required for each crop
    int totalWater = 11;

    int result = minWaterUsage(fields, totalWater);
    if (result != -1) {
        cout &lt;&lt; "Minimum number of fields irrigated: " &lt;&lt; result &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Not enough water available.\n";
    }

    return 0;
}
        </code>
        </pre>

        <h3>3. BFS (Breadth-First Search)</h3>
        <p>Description: BFS is used to traverse the irrigation pipeline graph to distribute water efficiently.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

using namespace std;

void bfsIrrigation(unordered_map&lt;int, vector&lt;int&gt;&gt; &graph, int start) {
    queue&lt;int&gt; q;
    vector&lt;bool&gt; visited(graph.size(), false);

    q.push(start);
    visited[start] = true;

    cout &lt;&lt; "Water Distribution Order:\n";
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout &lt;&lt; "Irrigating Field " &lt;&lt; node &lt;&lt; endl;

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    unordered_map&lt;int, vector&lt;int&gt;&gt; graph = {
        {1, {2, 3}},
        {2, {4, 5}},
        {3, {6}},
        {4, {}},
        {5, {}},
        {6, {}}
    };

    bfsIrrigation(graph, 1); // Start from Field 1

    return 0;
}
        </code>
        </pre>

        <h3>4. Dijkstra's Algorithm</h3>
        <p>Description: Dijkstra's algorithm is used to find the shortest pipeline path to a specific area, ensuring efficient water delivery.</p>
        <pre>
<code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;

using namespace std;

void dijkstra(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &graph, int start, int n) {
    vector&lt;int&gt; distance(n, INT_MAX);
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;

    distance[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        int dist = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        for (auto neighbor : graph[node]) {
            int nextNode = neighbor.first;
            int edgeWeight = neighbor.second;

            if (distance[node] + edgeWeight < distance[nextNode]) {
                distance[nextNode] = distance[node] + edgeWeight;
                pq.push({distance[nextNode], nextNode});
            }
        }
    }

    cout &lt;&lt; "Shortest Path from Field " &lt;&lt; start &lt;&lt; ":\n";
    for (int i = 0; i < n; ++i) {
        cout &lt;&lt; "To Field " &lt;&lt; i &lt;&lt; ": " &lt;&lt; (distance[i] == INT_MAX ? -1 : distance[i]) &lt;&lt; endl;
    }
}

int main() {
    int n = 5; // Number of fields
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);

    // Graph: {to, weight}
    graph[0] = {{1, 2}, {2, 4}};
    graph[1] = {{2, 1}, {3, 7}};
    graph[2] = {{3, 3}};
    graph[3] = {{4, 1}};
    graph[4] = {};

    dijkstra(graph, 0, n); // Start from Field 0

    return 0;
}
        </code>
        </pre>
    </section>

    <section>
        <header>
